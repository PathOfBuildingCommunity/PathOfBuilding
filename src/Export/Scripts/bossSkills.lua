--local out = io.open("../Data/BossSkills.lua", "w")
--out:write('-- This file is automatically generated, do not edit!\n')
--out:write('-- Boss Skill data (c) Grinding Gear Games\n\nreturn {\n')
--out:write('}')
--out:close()

local m_ceil = math.ceil
local m_min = math.min
local m_max = math.max

local rarityDamageMult = {
	--Unique = (1 + dat("Mods"):GetRow("Id", "MonsterUnique5").Stat1Value[1] / 100) * (1 - dat("Mods"):GetRow("Id", "MonsterUnique8").Stat1Value[1] / 100)
}

-- exports and calculates the damage multipliers of the skill
-- min and max damage equal to damage delt divided by base monster damage at that level
-- also provides the UberDamageMultiplier if the skill does more in uber form
local function calcSkillDamage(state)
	local monsterBaseDamage = { 821.73 }
	local monsterLevel = 1
	local baseDamage = {
		AtziriFlameblast = { Fire = { 1210.408, 0 } },
		AtlasBossAcceleratingProjectiles = { Cold = { 3523.578, 0 } },
		AtlasBossFlickerSlam = { Physical = { 1857.932, 0 }, ExtraDamageMult = 3.0, SkillUberDamageMult = 200 },
		AtlasExileOrionCircleMazeBlast3 = { Physical = { 18154.481, 0 }, SkillUberDamageMult = 150 },
		CleansingFireWall = { Fire = { 3422.505, 20 } },
		GSConsumeBossDisintegrateBeam = { Lightning = { 3875.279, 50 } },
		MavenSuperFireProjectileImpact = { Fire = { 5167.038, 0 }, SkillUberDamageMult = 200 },
		MavenMemoryGame = { Physical = { 35464.223, 0 } },
	}
	local skill = state.skill
	local boss = state.boss
	local physConversions = { 1, 0, 0, 0, 0 }
	for i, constStat in ipairs(skill.GrantedEffectStatSets.ConstantStats) do
		if constStat.Id == "skill_physical_damage_%_to_convert_to_lightning" then
			physConversions[2] = skill.GrantedEffectStatSets.ConstantStatsValues[i]
		elseif constStat.Id == "skill_physical_damage_%_to_convert_to_cold" then
			physConversions[3] = skill.GrantedEffectStatSets.ConstantStatsValues[i]
		elseif constStat.Id == "skill_physical_damage_%_to_convert_to_fire" then
			physConversions[4] = skill.GrantedEffectStatSets.ConstantStatsValues[i]
		elseif constStat.Id == "skill_physical_damage_%_to_convert_to_chaos" then
			physConversions[5] = skill.GrantedEffectStatSets.ConstantStatsValues[i]
		end
	end
	local grantedId = skill.grantedId
	if not baseDamage[grantedId] and baseDamage[skill.grantedId2] then
		grantedId = skill.grantedId2
	end
	if baseDamage[grantedId].Physical then
		local totalConversions = physConversions[2] + physConversions[3] + physConversions[4] + physConversions[5]
		local conversionDivisor = m_max(totalConversions, 100)
		physConversions = { m_max(1 - totalConversions / 100, 0), physConversions[2] / conversionDivisor, physConversions[3] / conversionDivisor, physConversions[4] / conversionDivisor, physConversions[5] / conversionDivisor }
	end
	if baseDamage[grantedId].Physical and physConversions[1] ~= 0 then
		local damageRange = (baseDamage[grantedId].Physical[2] == 0) and (boss.damageRange / 100) or baseDamage[grantedId].Physical[2] / 100
		local calcedMult = baseDamage[grantedId].Physical[1] * physConversions[1] * state.SkillExtraDamageMult * (baseDamage[grantedId].ExtraDamageMult or 1) * boss.damageMult / 100 * (rarityDamageMult[boss.rarity] or 1) / (monsterBaseDamage[monsterLevel] or 1)
		state.DamageData["PhysicalDamageMultMin"], state.DamageData["PhysicalDamageMultMax"] = calcedMult * ( 1 - damageRange ), calcedMult * ( 1 + damageRange )
	end
	for i, damageType in ipairs({"Lightning", "Cold", "Fire", "Chaos"}) do
		if baseDamage[grantedId][damageType] or (baseDamage[grantedId].Physical and physConversions[i + 1] ~= 0) then
			local damageMult = state.SkillExtraDamageMult * (baseDamage[grantedId].ExtraDamageMult or 1) * boss.damageMult / 100 * (rarityDamageMult[boss.rarity] or 1) / (monsterBaseDamage[monsterLevel] or 1)
			state.DamageData[damageType.."DamageMultMin"], state.DamageData[damageType.."DamageMultMax"] = 0, 0
			if baseDamage[grantedId][damageType] then
				local damageRange = (baseDamage[grantedId][damageType][2] == 0) and (boss.damageRange / 100) or baseDamage[grantedId][damageType][2] / 100
				local calcedMult = baseDamage[grantedId][damageType][1] * damageMult
				state.DamageData[damageType.."DamageMultMin"], state.DamageData[damageType.."DamageMultMax"] = calcedMult * ( 1 - damageRange ), calcedMult * ( 1 + damageRange )
			end
			if baseDamage[grantedId].Physical and physConversions[i + 1] ~= 0 then
				local damageRange = (baseDamage[grantedId].Physical[2] == 0) and (boss.damageRange / 100) or baseDamage[grantedId].Physical[2] / 100
				local calcedMult = (baseDamage[grantedId].Physical[1] * physConversions[i + 1]) * damageMult
				state.DamageData[damageType.."DamageMultMin"] = state.DamageData[damageType.."DamageMultMin"] + calcedMult * ( 1 - damageRange )
				state.DamageData[damageType.."DamageMultMax"] = state.DamageData[damageType.."DamageMultMax"] + calcedMult * ( 1 + damageRange )
			end
		end
	end
	if baseDamage[grantedId].SkillUberDamageMult then
		state.DamageData.SkillUberDamageMult = baseDamage[grantedId].SkillUberDamageMult
	end
end

-- exports non-damage stats
-- possible stats: DamageType, Penetration, Speed
local function getStat(state, stat)
	local DamageData = state.DamageData
	local skill = state.skill
	local boss = state.boss
	if stat == "DamageType" then
		local DamageType = "Melee"
		for _, skillType in ipairs(skill.skillData.ActiveSkill.SkillTypes) do
			if skillType.Id == "Spell" then
				if DamageType == "Projectile" then
					DamageType = "SpellProjectile"
				else
					DamageType = "Spell"
				end
			elseif skillType.Id  == "Projectile" then
				if DamageType == "Spell" then
					DamageType = "SpellProjectile"
				else
					DamageType = "Projectile"
				end
			end
		end
		if DamageType == "Melee" then
			for _, implicitStat in ipairs(skill.GrantedEffectStatSets.ImplicitStats) do
				if implicitStat.Id  == "base_is_projectile" then
					DamageType = "Projectile"
					break
				end
			end
		end
		return DamageType
	elseif stat == "Penetration" then
		DamageData["PhysOverwhelm"], DamageData["PhysUberOverwhelm"], DamageData["LightningPen"], DamageData["LightningUberPen"], DamageData["ColdPen"], DamageData["ColdUberPen"], DamageData["FirePen"], DamageData["FireUberPen"], DamageData["ChaosPen"], DamageData["ChaosUberPen"] = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
		for level, statsPerLevel in ipairs(skill.statsPerLevel) do
			for i, additonalStat in ipairs(statsPerLevel.AdditionalStats) do
				if additonalStat.Id == "base_reduce_enemy_lightning_resistance_%" then
					DamageData["Lightning"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "base_reduce_enemy_cold_resistance_%" then
					DamageData["Cold"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "base_reduce_enemy_fire_resistance_%" then
					DamageData["Fire"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "base_reduce_enemy_chaos_resistance_%" then
					DamageData["Chaos"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
				end
			end
		end
		if boss.earlierUber then
			local statsPerLevel = skill.statsPerLevelUber[2]
			for i, additonalStat in ipairs(statsPerLevel.AdditionalStats) do
				if additonalStat.Id == "base_reduce_enemy_lightning_resistance_%" then
					DamageData["LightningUberPen"] = statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "base_reduce_enemy_cold_resistance_%" then
					DamageData["ColdUberPen"] = statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "base_reduce_enemy_fire_resistance_%" then
					DamageData["FireUberPen"] = statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "base_reduce_enemy_chaos_resistance_%" then
					DamageData["ChaosUberPen"] = statsPerLevel.AdditionalStatsValues[i]
				end
			end
		elseif skill.statsPerLevel2 then 
			for level, statsPerLevel in ipairs(skill.statsPerLevel2) do
				for i, additonalStat in ipairs(statsPerLevel.AdditionalStats) do
					if additonalStat.Id == "base_reduce_enemy_lightning_resistance_%" then
						DamageData["Lightning"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
					elseif additonalStat.Id == "base_reduce_enemy_cold_resistance_%" then
						DamageData["Cold"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
					elseif additonalStat.Id == "base_reduce_enemy_fire_resistance_%" then
						DamageData["Fire"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
					elseif additonalStat.Id == "base_reduce_enemy_chaos_resistance_%" then
						DamageData["Chaos"..(level > 1 and "Uber" or "").."Pen"] = statsPerLevel.AdditionalStatsValues[i]
					end
				end
			end
		end
		DamageData["PhysOverwhelm"] = (DamageData["PhysOverwhelm"] == 0) and (DamageData["PhysUberOverwhelm"] ~= 0 and "" or DamageData["PhysOverwhelm"]) or DamageData["PhysOverwhelm"]
		for _, damageType in ipairs({"Lightning", "Cold", "Fire"}) do
			DamageData[damageType.."Pen"] = (DamageData[damageType.."Pen"] == 0) and (DamageData[damageType.."UberPen"] ~= 0 and "" or DamageData[damageType.."Pen"]) or DamageData[damageType.."Pen"]
		end
		return (DamageData["PhysOverwhelm"] ~= 0 or DamageData["LightningPen"] ~= 0 or DamageData["ColdPen"] ~= 0 or DamageData["FirePen"] ~= 0)
	elseif stat == "Speed" then
		local speed = skill.skillData.CastTime
		local uberSpeed
		if skill.skillDataUber then
			uberSpeed = skill.skillDataUber.CastTime
		end
		local speedMult = { 0, 0 }
		for level, statsPerLevel in ipairs(skill.statsPerLevel) do
			if level > 2 then
				break
			end
			for i, additonalStat in ipairs(statsPerLevel.AdditionalStats) do
				if additonalStat.Id == "active_skill_attack_speed_+%_final" then
					speedMult[level] = 100 + statsPerLevel.AdditionalStatsValues[i]
				elseif additonalStat.Id == "active_skill_cast_speed_+%_final" then
					speedMult[level] = 100 + statsPerLevel.AdditionalStatsValues[i]
				end
			end
		end
		if skill.speedMult then
			speed = speed * skill.speedMult / 10000
			if uberSpeed then
				uberSpeed = uberSpeed * skill.speedMult / 10000
			end
		end
		if speedMult[1] ~= 0 then
			if speedMult[1] ~= speedMult[2] then
				return tonumber(m_ceil(speed / speedMult[1] * 100)), tonumber(m_ceil(speed / speedMult[2] * 100))
			end
			speed = speed / speedMult[1] * 100
			uberSpeed = uberSpeed / speedMult[1] * 100
		end
		if uberSpeed then
			return tonumber(m_ceil(speed)), tonumber(m_ceil(uberSpeed))
		end
		return tonumber(m_ceil(speed))
	end
end

local directiveTable = {}

-- #boss [<Display name>] <MonsterId> <earlierUber>
-- Initialises the boss
directiveTable.boss = function(state, args, out)
	local displayName, monsterId, earlierUber = args:match("(%w+) (.+) (%w+)")
	if not displayName then
		displayName = args
		monsterId = args
	end
	local bossData = dat("MonsterVarieties"):GetRow("Id", monsterId)
	state.boss = { displayName = displayName, damageRange = bossData.Type.DamageSpread, damageMult = bossData.DamageMultiplier, critChance = m_ceil(bossData.CriticalStrikeChance / 100) }
	if earlierUber == "true" then
		state.boss.earlierUber = true
	end
	for _, mod in ipairs(bossData.Mods) do
		if mod.Id == "MonsterMapBoss" then
			state.boss.rarity = "Unique"
			break
		end
	end
end

-- #skill [<Display name>] [<GrantedEffectId>]
-- optional#  <GrantedEffectId2> <GrantedEffectIdUber> <SkillExtraDamageMult> <speedMult>
-- Initialises and emits the skill data
directiveTable.skill = function(state, args, out)
	local displayName, grantedId = args:match("(%w+) (%w+)")
	if not grantedId then
		displayName, grantedId = args
	end
	local boss = state.boss
	local skill = {}
	local skillData = dat("GrantedEffects"):GetRow("Id", grantedId)
	local GrantedEffectStatSets = dat("GrantedEffectStatSets"):GetRow("Id", grantedId)
	local statsPerLevel = dat("GrantedEffectStatSetsPerLevel"):GetRowList("GrantedEffect", skillData)
	skill = { skillData = skillData, displayName = displayName, GrantedEffectStatSets = GrantedEffectStatSets, statsPerLevel = statsPerLevel, grantedId = grantedId }
	state.skill = skill
	local grantedId2 = args:match("GrantedEffectId2 = (%w+),")
	if grantedId2 then
		skill.skillData2 = dat("GrantedEffects"):GetRow("Id", grantedId2)
		skill.statsPerLevel2 = dat("GrantedEffectStatSetsPerLevel"):GetRowList("GrantedEffect", skill.skillData2)
		skill.grantedId2 = grantedId2
	end
	local grantedIdUber = args:match("GrantedEffectIdUber = (%w+),")
	if grantedIdUber then
		skill.skillDataUber = dat("GrantedEffects"):GetRow("Id", grantedIdUber)
		skill.statsPerLevelUber = dat("GrantedEffectStatSetsPerLevel"):GetRowList("GrantedEffect", skill.skillDataUber)
		skill.grantedIdUber = grantedIdUber
	end
	state.SkillExtraDamageMult = args:match("ExtraDamageMult = (%d+),")
	state.SkillExtraDamageMult = state.SkillExtraDamageMult and (state.SkillExtraDamageMult / 100) or 1
	local DamageData = {}
	state.DamageData = DamageData
	calcSkillDamage(state)
	-- output
	out:write('	["', boss.displayName, " ", displayName, '"] = {\n')
	out:write('		DamageType = "', getStat(state, "DamageType"),'",\n')
	out:write('		DamageMultipliers = {\n')
	local dCount = 0
	for i, damageType in ipairs({"Physical", "Lightning", "Cold", "Fire", "Chaos"}) do
		if DamageData[damageType.."DamageMultMin"] then
			dCount = dCount + 1
			out:write(dCount > 1 and ',\n' or '', '			', damageType, ' = { ', DamageData[damageType.."DamageMultMin"], ', ', (DamageData[damageType.."DamageMultMax"] - DamageData[damageType.."DamageMultMin"]) / 100, ' }')
		end
	end
	if dCount == 0 then
		print("error skill: "..skill.displayName.." has no damage")
	end
	out:write('\n		}')
	if DamageData.SkillUberDamageMult then
		out:write(',\n		UberDamageMultiplier = ', (DamageData.SkillUberDamageMult / 100))
	end
	if getStat(state, "Penetration") then
		out:write(',\n		DamagePenetrations = {\n')
		dCount = 0
		for _, penType in ipairs({"PhysOverwhelm", "LightningPen", "ColdPen", "FirePen"}) do
			if DamageData[penType] ~= 0 then
				dCount = dCount + 1
				out:write(dCount > 1 and ',\n' or '', '			', penType, ' = ', (DamageData[penType] == "" and '""' or DamageData[penType]))
			end
		end
		out:write('\n		}')
		if DamageData["PhysUberOverwhelm"] ~= 0 or DamageData["LightningUberPen"] ~= 0 or DamageData["ColdUberPen"] ~= 0 or DamageData["FireUberPen"] ~= 0 then
			out:write(',\n		UberDamagePenetrations = {\n')
			dCount = 0
			for _, penType in ipairs({"PhysUberOverwhelm", "LightningUberPen", "ColdUberPen", "FireUberPen"}) do
				if DamageData[penType] ~= 0 then
					dCount = dCount + 1
					out:write(dCount > 1 and ',\n' or '', '			', penType:gsub("Uber", ""), ' = ', DamageData[penType])
				end
			end
			out:write('\n		}')
		end
	end
	skill.speedMult = args:match("speedMult = (%d+),")
	local speed, uberSpeed = getStat(state, "Speed")
	if speed and speed ~= 700 then
		out:write(',\n		speed = ', speed)
	end
	if uberSpeed and uberSpeed ~= 700 then
		out:write(',\n		Uberspeed = ', uberSpeed)
	end
	local critChance = statsPerLevel[1].AttackCritChance
	if critChance or boss.critChance then
		critChance = critChance and (m_ceil(critChance / 100)) or boss.critChance
		if critChance ~= 5 then
			out:write(',\n		critChance = ', critChance)
		end
	end
	if boss.earlierUber then
		out:write(',\n		earlierUber = true')
	end
end

 -- #tooltip
 directiveTable.tooltip = function(state, args, out)
	if args then
		out:write(',\n		tooltip = ', args,'\n')
	end
	out:write('	},\n')
	state.skill = nil
end

processTemplateFile("bossSkills", "", "../Data/", directiveTable)

print("Boss skill data exported.")
