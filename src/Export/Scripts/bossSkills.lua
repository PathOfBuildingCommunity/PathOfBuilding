--local out = io.open("../Data/BossSkills.lua", "w")
--out:write('-- This file is automatically generated, do not edit!\n')
--out:write('-- Boss Skill data (c) Grinding Gear Games\n\nreturn {\n')
--out:write('}')
--out:close()

local m_ceil = math.ceil
local m_min = math.min
local m_max = math.max

local rarityDamageMult = {
	--Unique = (1 + dat("Mods"):GetRow("Id", "MonsterUnique5").Stat1Value[1] / 100) * (1 - dat("Mods"):GetRow("Id", "MonsterUnique8").Stat1Value[1] / 100)
}

local directiveTable = {}

-- #boss [<Display name>] <MonsterId> <earlierUber>
-- Initialises the boss
directiveTable.boss = function(state, args, out)
	local displayName, monsterId, earlierUber = args:match("(%w+) (.+) (%w+)")
	if not displayName then
		displayName = args
		monsterId = args
	end
	local bossData = dat("MonsterVarieties"):GetRow("Id", monsterId)
	state.boss = { displayName = displayName, damageRange = 20, damageMult = bossData.DamageMultiplier, critChance = m_ceil(bossData.CriticalStrikeChance / 100) }
	if earlierUber == "true" then
		state.boss.earlierUber = true
	end
	for _, mod in ipairs(bossData.Mods) do
		if mod.Id == "MonsterMapBoss" then
			state.boss.rarity = "Unique"
			break
		end
	end
end

-- #skill [<Display name>] <GrantedEffectId> <UberGrantedEffectId>
-- Initialises the skill data and emits the skill header
directiveTable.skill = function(state, args, out)
	local displayName, grantedId = args:match("(%w+) (.+)")
	if not displayName then
		displayName = args
		grantedId = args
	end
	state.skill = { displayName = displayName }
	out:write('	["', state.boss.displayName, " ", displayName, '"] = {\n')
end

-- #skillData <DamageType> <SkillExtraDamageMult> <PhysDamageMult> <PhysOverwhelm> <PhysUberOverwhelm> <PhysDamageRange> <PhysToLightning> <PhysToCold> <PhysToFire> <PhysToChaos>
-- <LightningDamageMult> <LightningPen> <LightningUberPen> ... <ChaosDamageMult> <ChaosPen> <ChaosUberPen> <ChaosDamageRange>
-- <SkillUberDamageMult> <speed> <critChance>
-- Emits the skill modifiers
directiveTable.skillData = function(state, args, out)
	local DamageData = {}
	local DamageType, SkillExtraDamageMult, SkillUberDamageMult, speed, critChance
	DamageType, SkillExtraDamageMult, DamageData["PhysDamageMult"], DamageData["PhysOverwhelm"], DamageData["PhysUberOverwhelm"], DamageData["PhysDamageRange"], DamageData["PhysToLightning"], DamageData["PhysToCold"], DamageData["PhysToFire"], DamageData["PhysToChaos"], DamageData["LightningDamageMult"], DamageData["LightningPen"], DamageData["LightningUberPen"], DamageData["LightningDamageRange"], DamageData["ColdDamageMult"], DamageData["ColdPen"], DamageData["ColdUberPen"], DamageData["ColdDamageRange"], DamageData["FireDamageMult"], DamageData["FirePen"], DamageData["FireUberPen"], DamageData["FireDamageRange"], DamageData["ChaosDamageMult"], DamageData["ChaosPen"], DamageData["ChaosUberPen"], DamageData["ChaosDamageRange"], SkillUberDamageMult, speed, critChance = args:match("(%w+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+) (%d+)")
	local skill = state.skill
	local boss = state.boss
	-- cleanup/precompute some data
	for ind, val in pairs(DamageData) do
		DamageData[ind] = tonumber(val)
	end
	DamageData["PhysOverwhelm"] = (DamageData["PhysOverwhelm"] == 0) and (DamageData["PhysUberOverwhelm"] ~= 0 and "" or DamageData["PhysOverwhelm"]) or DamageData["PhysOverwhelm"]
	for _, damageType in ipairs({"Lightning", "Cold", "Fire"}) do
		DamageData[damageType.."Pen"] = (DamageData[damageType.."Pen"] == 0) and (DamageData[damageType.."UberPen"] ~= 0 and "" or DamageData[damageType.."Pen"]) or DamageData[damageType.."Pen"]
	end
	SkillExtraDamageMult = SkillExtraDamageMult == "0" and 1 or  SkillExtraDamageMult / 100
	speed = (speed == "700") and 0 or tonumber(speed)
	critChance = (critChance == "0") and ((boss.critChance ~= 5) and boss.critChance or 0) or ((critChance == "500") and 0 or m_ceil(critChance / 100))
	if DamageType ~= "_" then
		out:write('		DamageType = "', DamageType,'",\n')
	end
	if DamageData.PhysDamageMult == 0 and DamageData.LightningDamageMult == 0 and DamageData.ColdDamageMult == 0 and DamageData.FireDamageMult == 0 and DamageData.ChaosDamageMult == 0 then
		print("error skill: "..skill.displayName.." has no damage")
	end
	out:write('		DamageMultipliers = {\n')
	local dCount = 0
	local physConversions = { 1, 0, 0, 0, 0 }
	if DamageData.PhysDamageMult ~= 0 then
		local totalConversions = DamageData.PhysToLightning + DamageData.PhysToCold + DamageData.PhysToFire + DamageData.PhysToChaos
		physConversions = { m_max(1 - totalConversions / 100, 0), DamageData.PhysToLightning / m_max(totalConversions, 100), DamageData.PhysToCold / m_max(totalConversions, 100), DamageData.PhysToFire / m_max(totalConversions, 100), DamageData.PhysToChaos / m_max(totalConversions, 100) }
	end
	if DamageData.PhysDamageMult ~= 0 and physConversions[1] ~= 0 then
		dCount = dCount + 1
		local damageRange = (DamageData.PhysDamageRange == 0) and (boss.damageRange / 100) or DamageData.PhysDamageRange / 100
		local calcedMult = DamageData.PhysDamageMult / 1000 * physConversions[1] * SkillExtraDamageMult * boss.damageMult / 100 * (rarityDamageMult[boss.rarity] or 1)
		local MultMin, MultMax =  calcedMult * ( 1 - damageRange ), calcedMult * damageRange * 2 / 100
		out:write('			Physical = { ', MultMin, ', ', MultMax, ' }')
	else
		DamageData["PhysOverwhelm"] = 0
	end
	for i, damageType in ipairs({"Lightning", "Cold", "Fire", "Chaos"}) do
		if DamageData[damageType.."DamageMult"] ~= 0 or physConversions[i + 1] ~= 0 then
			dCount = dCount + 1
			local damageRange = (DamageData[damageType.."DamageRange"] == 0) and (boss.damageRange / 100) or DamageData[damageType.."DamageRange"] / 100
			local calcedMult = (DamageData[damageType.."DamageMult"] / 1000 + DamageData.PhysDamageMult / 1000 * physConversions[i + 1]) * SkillExtraDamageMult * boss.damageMult / 100 * (rarityDamageMult[boss.rarity] or 1)
			local MultMin, MultMax =  calcedMult * ( 1 - damageRange ), calcedMult * damageRange * 2 / 100
			out:write(dCount > 1 and ',\n' or '', '			', damageType, ' = { ', MultMin, ', ', MultMax, ' }')
		else
			DamageData[damageType.."Pen"] = 0
			DamageData[damageType.."UberPen"] = 0
		end
	end
	out:write('\n		}')
	if SkillUberDamageMult ~= "0" then
		out:write(',\n		UberDamageMultiplier = ', (1 + SkillUberDamageMult / 100))
	end
	if DamageData["PhysOverwhelm"] ~= 0 or DamageData["LightningPen"] ~= 0 or DamageData["ColdPen"] ~= 0 or DamageData["FirePen"] ~= 0 then
		out:write(',\n		DamagePenetrations = {\n')
		dCount = 0
		for i, penType in ipairs({"PhysOverwhelm", "LightningPen", "ColdPen", "FirePen"}) do
			if DamageData[penType] ~= 0 then
				dCount = dCount + 1
				out:write(dCount > 1 and ',\n' or '', '			', penType, ' = ', (DamageData[penType] == "" and '""' or DamageData[penType]))
			end
		end
		out:write('\n		}')
		if DamageData["PhysUberOverwhelm"] ~= 0 or DamageData["LightningUberPen"] ~= 0 or DamageData["ColdUberPen"] ~= 0 or DamageData["FireUberPen"] ~= 0 then
			out:write(',\n		UberDamagePenetrations = {\n')
			dCount = 0
			for i, penType in ipairs({"PhysUberOverwhelm", "LightningUberPen", "ColdUberPen", "FireUberPen"}) do
				if DamageData[penType] ~= 0 then
					dCount = dCount + 1
					out:write(dCount > 1 and ',\n' or '', '			', penType:gsub("Uber", ""), ' = ', DamageData[penType])
				end
			end
			out:write('\n		}')
		end
	end
	if speed ~= 0 then
		out:write(',\n		speed = ', speed)
	end
	if critChance ~= 0 then
		if critChance == 1000 then
			out:write(',\n		critChance = 0')
		else
			out:write(',\n		critChance = ', critChance)
		end
	end
	if boss.earlierUber then
		out:write(',\n		earlierUber = true')
	end
end

 -- #tooltip
 directiveTable.tooltip = function(state, args, out)
	if args then
		out:write(',\n		tooltip = ', args,'\n')
	end
	out:write('	},\n')
	state.skill = nil
end

processTemplateFile("bossSkills", "", "../Data/", directiveTable)

print("Boss skill data exported.")
