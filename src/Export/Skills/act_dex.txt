-- Path of Building
--
-- Active Dexterity skill gems
-- Skill data (c) Grinding Gear Games
--
local skills, mod, flag, skill = ...

#skill AlchemistsMark
#flags spell curse mark area duration
	statMap = {
		["alchemists_mark_igniter_creates_burning_ground_%_ignite_damage"] = {
			mod("IgniteDpsAsBurningGround", "MAX", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["alchemists_mark_poisoner_creates_caustic_ground_%_poison_damage"] = {
			mod("PoisonDpsAsCausticGround", "MAX", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["alchemists_mark_grant_attacker_x_flask_charges_when_hit_once_per_3s"] = {
			-- Uncomment below and delete subsequent line when we get "per hit" flask charge generation working
			-- mod("FlaskChargesGenerated", "BASE", nil, 0, KeywordFlag.Hit, { type = "ActorCondition", actor = "enemy", var = "Cursed" }),
			-- Delete this line if you uncomment the one above: this assume we are hitting the marked target as often as we can
			mod("FlaskChargesGenerated", "BASE", nil),
			div = 3,
		},
	},
#baseMod skill("debuff", true)
#baseMod skill("radius", 20)
#mods

#skill Ambush
#flags spell movement duration travel
#mods

#skill AnimateWeapon
#flags spell minion duration
	minionHasItemSet = true,
	minionUses = {
		["Weapon 1"] = true,
	},
	minionList = {
		"AnimatedWeapon",
	},
	statMap = {
		["base_movement_velocity_+%"] = {
			mod("MinionModifier", "LIST", { mod = mod("MovementSpeed", "INC", nil) }),
		},
		["attack_minimum_added_physical_damage"] = {
			mod("MinionModifier", "LIST", { mod = mod("PhysicalMin", "BASE", nil, 0, KeywordFlag.Attack) }),
		},
		["attack_maximum_added_physical_damage"] = {
			mod("MinionModifier", "LIST", { mod = mod("PhysicalMax", "BASE", nil, 0, KeywordFlag.Attack) }),
		},
		["attack_minimum_added_physical_damage_for_ethereal_blades"] = {
			mod("MinionModifier", "LIST", { mod = mod("PhysicalMin", "BASE", nil, 0, KeywordFlag.Attack, { type = "ActorCondition", actor = "parent", var = "AnimatingLingeringBlades" }) }),
		},
		["attack_maximum_added_physical_damage_for_ethereal_blades"] = {
			mod("MinionModifier", "LIST", { mod = mod("PhysicalMax", "BASE", nil, 0, KeywordFlag.Attack, { type = "ActorCondition", actor = "parent", var = "AnimatingLingeringBlades" }) }),
		},
		["minion_global_maximum_added_lightning_damage"] = {
			mod("MinionModifier", "LIST", { mod = mod("LightningMax", "BASE", nil, 0, KeywordFlag.Attack) }),
		},
		["number_of_animated_weapons_allowed"] = {
			mod("Multiplier:AnimatedWeapon", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff", unscalable = true })
		},
	},
#mods

#skill ArcticArmour
#flags spell duration
	statMap = {
		["new_arctic_armour_physical_damage_taken_when_hit_+%_final"] = {
			mod("PhysicalDamageTakenWhenHit", "MORE", nil, 0, 0, { type = "Condition", var = "Stationary" }, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["new_arctic_armour_fire_damage_taken_when_hit_+%_final"] = {
			mod("FireDamageTakenWhenHit", "MORE", nil, 0, 0, { type = "Condition", var = "Stationary" }, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["base_immune_to_freeze"] = {
			--Display only
		},
	},
#baseMod mod("AvoidFreeze", "BASE", 100, 0, 0, { type = "GlobalEffect", effectType = "Buff", unscalable = true })
#mods

#skill ArtilleryBallista
#flags attack projectile area totem ballista
#baseMod flag("OneShotProj")
#mods

#skill Barrage
#flags attack projectile
	parts = {
		{
			name = "1 Projectile",
		},
		{
			name = "All Projectiles",
		},
	},
	preDamageFunc = function(activeSkill, output)
		if activeSkill.skillPart == 2 then
			activeSkill.skillData.dpsMultiplier = output.ProjectileCount
		end
	end,
	statMap = {
		["non_damaging_ailments_as_though_damage_+%_final"] = {
			mod("ShockAsThoughDealing", "MORE", nil),
			mod("ChillAsThoughDealing", "MORE", nil),
			mod("FreezeAsThoughDealing", "MORE", nil),
			mod("ScorchAsThoughDealing", "MORE", nil),
			mod("BrittleAsThoughDealing", "MORE", nil),
			mod("SapAsThoughDealing", "MORE", nil),
		},
		["projectiles_barrage"] = {
		},
	},
#mods

#skill BearTrap
#flags cast trap duration
	statMap = {
		["bear_trap_damage_taken_+%_from_traps_and_mines"] = {
			mod("TrapMineDamageTaken", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Debuff" }),
		},
	},
#mods

#skill BladeBlast
#flags spell area
#baseMod skill("radius", 14)
	parts = {
		{
			name = "1 Blade",
		},
		{
			name = "3 Blades",
		},
		{
			name = "6 Blades",
		},
		{
			name = "10 Blades",
		},
		{
			name = "40 Blades",
		},
		{
			name = "50 Blades",
		},
	},
#baseMod skill("dpsMultiplier", 1, { type = "SkillPart", skillPart = 1 })
#baseMod skill("dpsMultiplier", 3, { type = "SkillPart", skillPart = 2 })
#baseMod skill("dpsMultiplier", 6, { type = "SkillPart", skillPart = 3 })
#baseMod skill("dpsMultiplier", 10, { type = "SkillPart", skillPart = 4 })
#baseMod skill("dpsMultiplier", 40, { type = "SkillPart", skillPart = 5 })
#baseMod skill("dpsMultiplier", 50, { type = "SkillPart", skillPart = 6 })
#mods

#skill BladeTrap
#flags attack area trap
#baseMod skill("radius", 16)
#mods

#skill ChargedAttack
#flags attack melee area
	parts = {
		{
			name = "Channelling",
			stages = true,
		},
		{
			name = "Channel & Release",
			stages = true,
		},
	},
	preDamageFunc = function(activeSkill, output)
		if activeSkill.skillPart == 2 and activeSkill.skillData.numStages > 0 then
			local numStages = activeSkill.skillData.numStages
			local channelMulti = 0
			for i = 1, numStages do
				channelMulti = channelMulti + (0.8 + (0.2 * i))
			end
			channelMulti = channelMulti / (0.8 + (0.2 * numStages))
			activeSkill.skillData.dpsMultiplier = channelMulti / numStages + 1
		end
	end,
	statMap = {
		["base_skill_show_average_damage_instead_of_dps"] = {
		},
		["charged_attack_damage_per_stack_+%_final"] = {
			mod("Damage", "MORE", nil, 0, bit.bor(KeywordFlag.Hit, KeywordFlag.Ailment), { type = "Multiplier", var = "BladeFlurryStage" }),
		},
		["blade_flurry_elemental_damage_+%_while_channeling"] = {
			mod("ElementalDamage", "INC", nil, 0, 0, { type = "SkillPart", skillPart = 1 })
		},
		["blade_flurry_final_flurry_area_of_effect_+%"] = {
			mod("AreaOfEffect", "INC", nil, 0, 0,  { type = "SkillPart", skillPart = 2 })
		}
	},
#baseMod mod("Multiplier:BladeFlurryMaxStages", "BASE", 6)
#baseMod skill("numStages", 1, { type = "Multiplier", var = "BladeFlurryStage" })
#baseMod skill("stackMultiplier", 2, { type = "SkillPart", skillPart = 2 })
#baseMod skill("radius", 14)
#mods

#skill VaalChargedAttack
#flags attack melee area
	statMap = {
		["vaal_charged_attack_damage_taken_+%_final"] = {
			mod("DamageTaken", "MORE", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
	},
#mods

#skill BladeVortex
#flags spell area duration
	parts = {
		{
			name = "0 Blades",
		},
		{
			name = "5 Blades",
		},
		{
			name = "10 Blades",
		},
	},
	statMap = {
		["blade_vortex_damage_+%_per_blade_final"] = {
			mod("Damage", "MORE", nil, 0, bit.bor(KeywordFlag.Hit, KeywordFlag.Ailment), { type = "Multiplier", var = "BladeVortexBlade" }),
		},
		["blade_vortex_ailment_damage_+%_per_blade_final"] = {
			mod("Damage", "MORE", nil, 0, KeywordFlag.Ailment, { type = "Multiplier", var = "BladeVortexBlade" }),
		},
		["blade_vortex_critical_strike_chance_+%_per_blade"] = {
			mod("CritChance", "INC", nil, 0, 0, { type = "Multiplier", var = "BladeVortexBlade" }),
		},
		["base_skill_show_average_damage_instead_of_dps"] = {
		},
		["blade_vortex_damage_+%_with_5_or_fewer_blades"] = {
			mod("Damage", "INC", nil, 0, 0, { type = "SkillPart", skillPartList = {1, 2} }),
		},
		["maximum_number_of_spinning_blades"] = {
			mod("Multiplier:BladeVortexMaxStages", "BASE", nil),
		},
		["blade_vortex_hit_rate_+%_per_blade"] = {
		},
	},
#baseMod skill("radius", 15)
#baseMod mod("Multiplier:BladeVortexBlade", "BASE", 5, 0, 0, { type = "SkillPart", skillPart = 2 })
#baseMod mod("Multiplier:BladeVortexBlade", "BASE", 10, 0, 0, { type = "SkillPart", skillPart = 3 })
#baseMod skill("hitTimeOverride", 0.6, { type = "SkillPart", skillPart = 1 })
#baseMod skill("hitTimeOverride", 0.6 / (1+5*0.35), { type = "SkillPart", skillPart = 2 })
#baseMod skill("hitTimeOverride", 0.6 / (1+10*0.35), { type = "SkillPart", skillPart = 3 })
#baseMod flag("Condition:HaveBladeVortex")
#mods

#skill VaalBladeVortex
#flags spell area duration
	statMap = {
		["base_blade_vortex_hit_rate_ms"] = {
			skill("hitTimeOverride", nil),
			div = 1000,
		},
	},
#baseMod skill("radius", 15)
#mods

#skill Bladefall
#flags spell area
#baseMod skill("radius", 44)
#baseMod skill("radiusLabel", "Volley Width:")
#baseMod skill("radiusSecondary", 12)
#baseMod skill("radiusSecondaryLabel", "Volley Length:")
#mods

#skill BlastRain
#flags attack projectile area
	parts = {
		{
			name = "1 Projectile",
		},
		{
			name = "All Projectiles",
		},
	},
	preDamageFunc = function(activeSkill, output)
		if activeSkill.skillPart == 2 then
			activeSkill.skillData.dpsMultiplier = output.ProjectileCount
		end
	end,
	statMap = {
		["blast_rain_damage_+%_vs_distant_enemies"] = { 
			mod("Damage", "INC", nil, bit.bor(ModFlag.Attack, ModFlag.Projectile), 0, { type = "DistanceRamp", ramp = {{35,0},{70,1}} }) 
		},
		["blast_rain_area_of_effect_+%"] = {
			-- Only affects primary area for overlaps
		}
	},
#baseMod skill("radius", 24)
#baseMod flag("OneShotProj")
#mods

#skill BlinkArrow
#flags attack projectile minion duration
	minionList = {
		"Clone",
	},
#baseMod skill("minionUseBowAndQuiver", true)
#mods

#skill BloodRage
#flags spell duration
	statMap = {
		["life_leech_from_physical_attack_damage_permyriad"] = {
			mod("PhysicalDamageLifeLeech", "BASE", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Buff" }),
			div = 100,
		},
		["base_physical_damage_%_of_maximum_life_to_deal_per_minute"] = {
			mod("PhysicalDegen", "BASE", nil, 0, 0, { type = "PerStat", stat = "Life", div = 1}, { type = "GlobalEffect", effectType = "Buff" }),
			div = 6000,
		},
		["base_physical_damage_%_of_maximum_energy_shield_to_deal_per_minute"] = {
			mod("PhysicalDegen", "BASE", nil, 0, 0, { type = "PerStat", stat = "EnergyShield", div = 1}, { type = "GlobalEffect", effectType = "Buff" }),
			div = 6000,
		},
		["attack_speed_+%_granted_from_skill"] = {
			mod("Speed", "INC", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["blood_rage_life_leech_from_elemental_damage_permyriad"] = {
			mod("FireDamageLifeLeech", "BASE", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Buff" }),
			mod("ColdDamageLifeLeech", "BASE", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Buff" }),
			mod("LightningDamageLifeLeech", "BASE", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Buff" }),
			div = 100
		}
	},
#baseMod skill("thisIsNotABuff", true)
#mods

#skill BurningArrow
#flags attack projectile
#mods

#skill VaalBurningArrow
#flags attack projectile area vaal
#baseMod skill("radius", 16)
#mods

#skill PoisonArrow
#flags attack projectile area duration
#baseMod skill("radius", 20)
#baseMod skill("radiusSecondary", 12)
#baseMod skill("dotIsArea", true)
#baseMod flag("dotIsCausticGround")
#mods

#skill VaalCausticArrow
#flags attack projectile area duration
#baseMod skill("radius", 20)
#baseMod skill("radiusSecondary", 12)
#baseMod skill("dotIsArea", true)
#baseMod flag("dotIsCausticGround")
#mods

#skill ImpactingSteelReload
#flags area
#mods

#skill ChargedDash
#flags attack melee area
	parts = {
		{
			name = "Channelling, No Stages",
		},
		{
			name = "Channelling, Max Stages",
		},
		{
			name = "Release",
			stages = true,
		},
	},
	preDamageFunc = function(activeSkill, output)
		   if activeSkill.skillPart == 3 then
			   local finalWaveDamageModifier = activeSkill.skillModList:Sum("INC", activeSkill.skillCfg, "chargedDashFinalDamageModifier")
			   activeSkill.skillModList:NewMod("Damage", "MORE", finalWaveDamageModifier, "Skill:ChargedDash", ModFlag.Attack, { type = "Release Damage", skillPart = 3 })
		   end
	end,
	statMap = {
		["base_skill_show_average_damage_instead_of_dps"] = {
		},
		["charged_dash_damage_+%_final"] = {
			mod("chargedDashFinalDamageModifier", "INC", nil, 0, 0, { type = "SkillPart", skillPart = 3 }),
		},
		["charged_dash_damage_+%_final_per_stack"] = {
			mod("chargedDashFinalDamageModifier", "INC", nil, 0, 0, { type = "Multiplier", var = "ChargedDashStage" }, { type = "SkillPart", skillPart = 3 }),
		},
		["charged_dash_channelling_damage_at_full_stacks_+%_final"] = {
			mod("Damage", "MORE", nil, 0, 0, { type = "SkillPart", skillPart = 2 }),
		},
	},
#baseMod skill("radius", 14)
#baseMod skill("radiusLabel", "Start of Dash:")
#baseMod skill("radiusSecondary", 26)
#baseMod skill("radiusSecondaryLabel", "End of Dash:")
#baseMod skill("hitTimeMultiplier", 2, { type = "Skill", skillPartList = { 1, 2 } })
#baseMod mod("Multiplier:ChargedDashMaxStages", "BASE", 15)
#baseMod skill("showAverage", true, { type = "SkillPart", skillPart = 3 })
#mods

#skill CobraLash
#flags attack projectile
	statMap = {
		["active_skill_projectile_damage_+%_final_for_each_remaining_chain"] = {
			mod("Damage", "MORE", nil, ModFlag.Projectile, 0, { type = "PerStat", stat = "ChainRemaining" })
		},
	},
#mods

#skill CorpseEruption
#flags spell projectile area
#baseMod skill("explodeCorpse", true, { type = "SkillPart", skillPart = 2 })
	parts = {
		{
			name = "Spell",
			spell = true,
			cast = false,
		},
		{
			name = "Corpse Explosion",
			spell = false,
			cast =  true,
		},
	},
	statMap = {
		["cremation_base_fires_projectile_every_x_ms"] = {
			skill("cremationFireRate", nil),
			div = 1000
		},
		["cremation_fires_projectiles_faster_+%_final"] = {
			skill("cremationFireRateIncrease", nil),
			div = 100
		},
		["base_skill_show_average_damage_instead_of_dps"] = {
		}
	},
	preDamageFunc = function(activeSkill, output)
		if activeSkill.skillPart == 1 then
			activeSkill.skillData.hitTimeOverride = activeSkill.skillData.cremationFireRate / (1 + (activeSkill.skillData.cremationFireRateIncrease or 0))
		end
	end,
#baseMod skill("radius", 15)
#mods

#skill Cyclone
#flags attack melee area
	statMap = {
		["cyclone_max_number_of_stages"] = {
			mod("Multiplier:CycloneMaxStages", "BASE", nil),
		},
		["cyclone_area_of_effect_+%_per_additional_melee_range"] = {
			mod("AreaOfEffect", "INC", nil, 0, 0, { type = "Multiplier", var = "AdditionalMeleeRange"}),
		},
		["cyclone_movement_speed_+%_final"] = {
			mod("MovementSpeed", "MORE", nil, 0, 0, { type = "Condition", var = "ChannellingCyclone"}, { type = "GlobalEffect", effectType = "Buff", unscalable = true }),
		},
		["cyclone_melee_weapon_range_+_per_stage"] = {
			skill("radiusExtra", nil, { type = "Multiplier", var = "CycloneStage" }),
		},
	},
	initialFunc = function(activeSkill, output)
		local range = 0
		if activeSkill.skillFlags.weapon1Attack and activeSkill.actor.weaponData1.range then
			local weapon1RangeBonus = activeSkill.skillModList:Sum("BASE", activeSkill.weapon1Cfg, "MeleeWeaponRange") + activeSkill.actor.weaponData1.rangeBonus
			if activeSkill.skillFlags.weapon2Attack and activeSkill.actor.weaponData2.range then -- dual wield average
				range = (weapon1RangeBonus + activeSkill.skillModList:Sum("BASE", activeSkill.weapon2Cfg, "MeleeWeaponRange") + activeSkill.actor.weaponData2.rangeBonus) / 2
			else -- primary hand attack
				range = weapon1RangeBonus
			end
		else -- unarmed
			range = activeSkill.skillModList:Sum("BASE", activeSkill.skillCfg, "UnarmedRange")
		end
		activeSkill.skillModList:NewMod("Multiplier:AdditionalMeleeRange", "BASE", range, "Skill:Cyclone")
	end,
#baseMod skill("radius", 11)
#mods

#skill VaalCyclone
#flags attack melee area duration vaal
	statMap = {
		["cyclone_area_of_effect_+%_per_additional_melee_range"] = {
			mod("AreaOfEffect", "INC", nil, 0, 0, { type = "Multiplier", var = "AdditionalMeleeRange"}),
		},
	},
	initialFunc = function(activeSkill, output)
		local range = 0
		if activeSkill.skillFlags.weapon1Attack and activeSkill.actor.weaponData1.range then
			local weapon1RangeBonus = activeSkill.skillModList:Sum("BASE", activeSkill.weapon1Cfg, "MeleeWeaponRange") + activeSkill.actor.weaponData1.rangeBonus
			if activeSkill.skillFlags.weapon2Attack and activeSkill.actor.weaponData2.range then -- dual wield average
				range = (weapon1RangeBonus + activeSkill.skillModList:Sum("BASE", activeSkill.weapon2Cfg, "MeleeWeaponRange") + activeSkill.actor.weaponData2.rangeBonus) / 2
			else -- primary hand attack
				range = weapon1RangeBonus
			end
		else -- unarmed
			range = activeSkill.skillModList:Sum("BASE", activeSkill.skillCfg, "UnarmedRange")
		end
		activeSkill.skillModList:NewMod("Multiplier:AdditionalMeleeRange", "BASE", range, "Skill:Cyclone")
	end,
#baseMod skill("radius", 24)
#mods

#skill QuickDodge
#flags spell
#mods

#skill Desecrate
#flags spell area duration
#baseMod skill("dotIsArea", true)
#baseMod skill("radius", 12)
#mods

#skill DetonateDead
#flags spell area
	statMap = {
		["spell_minimum_base_fire_damage"] = {
			skill("FireMin", nil, { type = "SkillPart", skillPart = 1 }),
		},
		["spell_maximum_base_fire_damage"] = {
			skill("FireMax", nil, { type = "SkillPart", skillPart = 1 }),
		},
	},
#baseMod skill("radius", 22)
#baseMod skill("explodeCorpse", true, { type = "SkillPart", skillPart = 2 })
	parts = {
		{
			name = "Spell",
			spell = true,
			cast = false,
		},
		{
			name = "Corpse Explosion",
			spell = false,
			cast =  true,
		},
	},
#mods

#skill VaalDetonateDead
#flags cast area
	statMap = {
		["spell_minimum_base_fire_damage"] = {
			skill("FireMin", nil, { type = "SkillPart", skillPart = 1 }),
		},
		["spell_maximum_base_fire_damage"] = {
			skill("FireMax", nil, { type = "SkillPart", skillPart = 1 }),
		},
	},
#baseMod skill("explodeCorpse", true, { type = "SkillPart", skillPart = 2 })
#baseMod skill("radius", 24)
	parts = {
		{
			name = "Spell",
			spell = true,
			cast = false,
		},
		{
			name = "Corpse Explosion",
			spell = false,
			cast =  true,
		},
	},
#mods

#skill DoubleStrike
#flags attack melee
#baseMod skill("dpsMultiplier", 2)
#baseMod mod("PvpTvalueMultiplier", "MORE", -50)
#mods

#skill VaalDoubleStrike
#flags attack melee duration vaal
#mods

#skill DualStrike
#flags attack melee
	statMap = {
		["dual_strike_critical_strike_chance_+%_final_against_enemies_on_full_life"] = {
			mod("CritChance", "MORE", nil, 0, 0, { type = "ActorCondition", actor = "enemy", var = "FullLife" })
		},
		["dual_strike_damage_+%_final_against_enemies_on_full_life"] = {
			mod("Damage", "MORE", nil, 0, bit.bor(KeywordFlag.Hit, KeywordFlag.Ailment), { type = "ActorCondition", actor = "enemy", var = "FullLife" })
		},
	},
#mods

#skill ElementalHit
#flags attack melee projectile
	parts = {
		{
			name = "Fire Attack",
			area = false,
		},
		{
			name = "Fire AoE",
			area = true,
		},
		{
			name = "Cold Attack",
			area = false,
		},
		{
			name = "Cold AoE",
			area = true,
		},
		{
			name = "Lightning Attack",
			area = false,
		},
		{
			name = "Lightning AoE",
			area = true,
		},
	},
	statMap = {
		["elemental_hit_damage_+10%_final_per_enemy_elemental_ailment"] = {
			mod("Damage", "MORE", nil, 0, 0, { type = "Multiplier", var = "ElementalHitAilmentOnEnemy" }),
			mult = 10,
		},
		["elemental_hit_area_of_effect_+100%_final_vs_enemy_with_associated_ailment"] = {
		},
		["elemental_hit_no_physical_chaos_damage"] = {
			flag("DealNoPhysical"),
			flag("DealNoChaos"),
			flag("DealNoFire", { type = "SkillPart", skillPartList = { 3, 4 } }),
			flag("DealNoFire", { type = "SkillPart", skillPartList = { 5, 6 } }),
			flag("DealNoCold", { type = "SkillPart", skillPartList = { 1, 2 } }),
			flag("DealNoCold", { type = "SkillPart", skillPartList = { 5, 6 } }),
			flag("DealNoLightning", { type = "SkillPart", skillPartList = { 1, 2 } }),
			flag("DealNoLightning", { type = "SkillPart", skillPartList = { 3, 4 } }),
		},
	},
#baseMod mod("AreaOfEffect", "MORE", 224, 0, 0, { type = "ActorCondition", actor = "enemy", varList = { "Ignited", "Scorched" } }, { type = "SkillPart", skillPart = 2 })
#baseMod mod("AreaOfEffect", "MORE", 224, 0, 0, { type = "ActorCondition", actor = "enemy", varList = { "Chilled", "Frozen", "Brittle" } }, { type = "SkillPart", skillPart = 4 })
#baseMod mod("AreaOfEffect", "MORE", 224, 0, 0, { type = "ActorCondition", actor = "enemy", varList = { "Shocked", "Sapped" } }, { type = "SkillPart", skillPart = 6 })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Ignited" })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Chilled" })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Frozen" })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Shocked" })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Scorched" })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Brittle" })
#baseMod mod("Multiplier:ElementalHitAilmentOnEnemy", "BASE", 1, 0, 0, { type = "ActorCondition", actor = "enemy", var = "Sapped" })
#baseMod skill("radius", 10, { type = "SkillPart", skillPartList = { 2, 4, 6 } })
#mods

#skill EnsnaringArrow
#flags attack projectile area
	statMap = {
		["tethered_enemies_take_attack_projectile_damage_taken_+%"] = {
			mod("ProjectileAttackDamageTaken", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Debuff", effectName = "Ensnared", effectStackVar = "EnsnareStackCount", effectStackLimit = 1 }),
		},
		["ensnaring_arrow_enemy_spell_damage_taken_+%"] = {
			mod("DamageTaken", "INC", nil, ModFlag.Spell, 0, { type = "GlobalEffect", effectType = "Debuff", effectName = "Ensnared", effectStackVar = "EnsnareStackCount", effectStackLimit = 1 }),
		},
	},
#mods

#skill EtherealKnives
#flags spell projectile
#mods

#skill ExplosiveArrow
#flags attack projectile area duration
	parts = {
		{
			name = "Explosion (# of fuses)",
			area = true,
			stages = true,
		},
		{
			name = "Explosion (Maximum Sustainable Fuses)",
			area = true,
		},
		{
			name = "Arrow",
			area = false,
		},
	},
	statMap = {
		["explosive_arrow_explosion_minimum_added_fire_damage"] = {
			mod("FireMin", "BASE", nil, 0, 0, { type = "SkillPart", skillPartList = { 1, 2 } }),
		},
		["explosive_arrow_explosion_maximum_added_fire_damage"] = {
			mod("FireMax", "BASE", nil, 0, 0, { type = "SkillPart", skillPartList = { 1, 2 } }),
		},
		["fuse_arrow_explosion_radius_+_per_fuse_arrow_orb"] = {
			skill("radiusExtra", nil, { type = "Multiplier", var = "ExplosiveArrowStage", limitVar = "ExplosiveArrowMaxBonusRadius", limitTotal = true }),
		},
		["explosive_arrow_explosion_base_damage_+permyriad"] = {
			skill("baseMultiplier", nil, { type = "SkillPart", skillPartList = { 1, 2 } }),
			div = -10000,
		},
		["explosive_arrow_hit_damage_+%_final_per_stack"] = {
			mod("Damage", "MORE", nil, 0, KeywordFlag.Hit, { type = "SkillPart", skillPartList = { 1, 2 } }, { type = "Multiplier", var = "ExplosiveArrowStage" }),
		},
		["explosive_arrow_ailment_damage_+%_final_per_stack"] = {
			mod("Damage", "MORE", nil, 0, KeywordFlag.Ailment, { type = "SkillPart", skillPartList = { 1, 2 } }, { type = "Multiplier", var = "ExplosiveArrowStage" }),
 		},
		["explosive_arrow_maximum_bonus_explosion_radius"] = {
			mod("Multiplier:ExplosiveArrowMaxBonusRadius", "BASE", nil),
		},
		["explosive_arrow_stack_limit"] = {
			mod("Multiplier:ExplosiveArrowMaxStages", "BASE", nil, 0, 0, { type = "SkillPart", skillPart = 1 }),
			mod("ExplosiveArrowMaxFuseCount", "BASE", nil),
		},
	},
#baseMod skill("radius", 15)
#baseMod skill("showAverage", true, { type = "SkillPart", skillPartList = { 1, 2 } })
#baseMod mod("Damage", "MORE", 100, 0, 0, { type = "SkillPart", skillPartList = { 1, 2 } }, { type = "Multiplier", var = "ExplosiveArrowStageAfterFirst" })
#mods

#skill ExplosiveConcoction
#flags attack area projectile
#baseMod skill("radius", 18)
	parts = {
		{
			name = "No Flasks",
		},
		{
			name = "Sapphire",
		},
		{
			name = "Topaz",
		},
		{
			name = "Ruby",
		},
		{
			name = "Sapphire + Topaz",
		},
		{
			name = "Sapphire + Ruby",
		},
		{
			name = "Topaz + Ruby",
		},
		{
			name = "All Flasks",
		},
	},
	statMap = {
		["flask_throw_minimum_cold_damage_if_used_sapphire_flask"] = {
			mod("ColdMin", "BASE", nil, 0, 0, { type = "SkillPart", skillPartList = { 2, 5, 6, 8 } }),
		},
		["flask_throw_maximum_cold_damage_if_used_sapphire_flask"] = {
			mod("ColdMax", "BASE", nil, 0, 0, { type = "SkillPart", skillPartList = { 2, 5, 6, 8 } }),
		},
		["flask_throw_minimum_lightning_damage_if_used_topaz_flask"] = {
			mod("LightningMin", "BASE", nil, 0, 0, { type = "SkillPart", skillPartList = { 3, 5, 7, 8 } }),
		},
		["flask_throw_maximum_lightning_damage_if_used_topaz_flask"] = {
			mod("LightningMax", "BASE", nil, 0, 0, { type = "SkillPart", skillPartList = { 3, 5, 7, 8 } }),
		},
		["flask_throw_ruby_flask_ignite_dot_multiplier_+"] = {
			mod("FireDotMultiplier", "BASE", nil, 0, KeywordFlag.Ignite, { type = "SkillPart", skillPartList = { 4, 6, 7, 8 } }),
		},
	},
#mods

#skill ShrapnelTrap
#flags spell trap area
	parts = {
		{
			name = "One explosion hitting",
		},
		{
			name = "Average explosions hitting",
		},
		{
			name = "All explosions hitting",
		},
	},
	preDamageFunc = function(activeSkill, output, breakdown)
		local skillCfg = activeSkill.skillCfg
		local skillData = activeSkill.skillData
		local skillPart = activeSkill.skillPart
		local skillModList = activeSkill.skillModList
		local t_insert = table.insert
		local s_format = string.format

		local function hitChance(enemyRadius, areaDamageRadius, areaSpreadRadius) -- not to be confused with attack hit chance
			local damagingAreaRadius = areaDamageRadius + enemyRadius - 1	-- radius where area damage can land to hit the enemy;
			-- -1 because of two assumptions: PoE coordinates are integers and damage is not registered if the two areas only share a point or vertex. If either is not correct, then -1 is not needed.
			return math.min(damagingAreaRadius * damagingAreaRadius / (areaSpreadRadius * areaSpreadRadius), 1)
		end
		local enemyRadius = skillModList:Override(skillCfg, "EnemyRadius") or skillModList:Sum("BASE", skillCfg, "EnemyRadius")
		local waveRadius = output.AreaOfEffectRadiusSecondary
		local fullRadius = output.AreaOfEffectRadius
		local overlapChance = hitChance(enemyRadius, waveRadius, fullRadius)
		output.OverlapChance = overlapChance * 100
		local smallExplosionsPerTrap = skillModList:Sum("BASE", skillCfg, "SmallExplosions")
		output.SmallExplosionsPerTrap = smallExplosionsPerTrap
		if breakdown then
			breakdown.OverlapChance = { }
			t_insert(breakdown.OverlapChance, "Chance for individual wave to land within range to damage enemy:")
			t_insert(breakdown.OverlapChance, "^8= (area where wave can spawn to damage enemy) / (total area)")
			t_insert(breakdown.OverlapChance, "^8= (^7secondary radius^8 + ^7enemy radius^8 - 1) ^ 2 / ^7radius^8 ^ 2")
			t_insert(breakdown.OverlapChance, s_format("^8= (^7%d^8 +^7 %d^8 - 1) ^ 2 /^7 %d^8 ^ 2", waveRadius, enemyRadius, fullRadius))
			t_insert(breakdown.OverlapChance, s_format("^8=^7 %.3f^8%%", overlapChance * 100))
		end
		local dpsMultiplier = 1
		if skillPart == 2 then
			dpsMultiplier = 1 + smallExplosionsPerTrap * overlapChance
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, "^8= 1 + ^7small explosions^8 * ^7overlap chance^8")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8= 1 +^7 %d^8 *^7 %.2f^8", smallExplosionsPerTrap, overlapChance))
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.3f", dpsMultiplier))
			end
		elseif skillPart == 3 then
			dpsMultiplier = 1 + smallExplosionsPerTrap
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8= 1 +^7 %d (small explosions)", dpsMultiplier))
			end
		end
		if dpsMultiplier ~= 1 then
			skillData.dpsMultiplier = (skillData.dpsMultiplier or 1) * dpsMultiplier
			output.SkillDPSMultiplier = (output.SkillDPSMultiplier or 1) * dpsMultiplier
		end
	end,
	statMap = {
		["shrapnel_trap_number_of_secondary_explosions"] = {
			mod("SmallExplosions", "BASE", nil),
		},
	},
#baseMod skill("radius", 12)
#baseMod skill("radiusLabel", "Primary Explosion:")
#baseMod skill("radiusSecondary", 7)
#baseMod skill("radiusSecondaryLabel", "Secondary Explosion:")
#mods

#skill FireTrap
#flags spell trap area duration
#baseMod skill("dotIsArea", true)
#baseMod flag("dotIsBurningGround")
#baseMod skill("radius", 15)
#mods

#skill FlamethrowerTrap
#flags spell trap area duration
	preDamageFunc = function(activeSkill, output, breakdown)
		-- many unknown stats. can't calculate DPS
		local t_insert = table.insert
		local s_format = string.format

		local duration = output.Duration
		local cooldown = output.TrapCooldown
		local averageActiveTraps = duration / cooldown
		output.AverageActiveTraps = averageActiveTraps
		if breakdown then
			breakdown.AverageActiveTraps = { }
			t_insert(breakdown.AverageActiveTraps, "Average active traps, not considering stored cooldown uses:")
			t_insert(breakdown.AverageActiveTraps, s_format("%.2f^8 (skill duration)", duration))
			t_insert(breakdown.AverageActiveTraps, s_format("/ %.2f^8 (cooldown)", cooldown))
			t_insert(breakdown.AverageActiveTraps, s_format("= %.2f traps", averageActiveTraps))
		end
	end,
	statMap = {
		["flamethrower_trap_damage_+%_final_vs_burning_enemies"] = {
			mod("Damage", "MORE", nil, bit.band(ModFlag.Hit, ModFlag.Ailment), 0, { type = "ActorCondition", actor = "enemy", var = "Burning" }),
		},
	},
#baseMod skill("radius", 32)
#mods

#skill FlickerStrike
#flags attack melee duration
	statMap = {
		["flicker_strike_more_attack_speed_+%_final"] = {
			mod("Speed", "MORE", nil, ModFlag.Attack),
		},
		["base_skill_show_average_damage_instead_of_dps"] = {
		},
		["flicker_strike_buff_movement_speed_+%"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
	},
#mods

#skill VaalFlickerStrike
#flags attack melee duration
#mods

#skill Frenzy
#flags attack melee projectile
	statMap = {
		["frenzy_skill_attack_damage_+%_final_per_frenzy_charge"] = {
			mod("Damage", "MORE", nil, ModFlag.Attack, 0, { type = "Multiplier", var = "FrenzyCharge" }),
		},
		["frenzy_skill_attack_speed_+%_final_per_frenzy_charge"] = {
			mod("Speed", "MORE", nil, ModFlag.Attack, 0, { type = "Multiplier", var = "FrenzyCharge" }),
		},
	},
#mods

#skill FrostBlades
#flags attack melee projectile
	parts = {
		{
			name = "Melee hit",
			melee = true,
			projectile = false,
		},
		{
			name = "Icy blades",
			melee = false,
			projectile = true,
		},
	},
#mods

#skill ShrapnelShot
#flags attack projectile area
	parts = {
		{
			name = "Arrow",
			area = false,
		},
		{
			name = "Cone",
			area = true,
		},
	},
#baseMod skill("radius", 28)
#mods

#skill Grace
#flags spell aura area
	statMap = {
		["grace_aura_evasion_rating_+%_final"] = {
			mod("Evasion", "MORE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_evasion_rating"] = {
			mod("Evasion", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["avoid_all_elemental_status_%"] = {
			mod("AvoidElementalAilments", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["avoid_chaos_damage_%"] = {
			mod("AvoidChaosDamageChance", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" })
		},
	},
#baseMod skill("radius", 40)
#mods

#skill VaalGrace
#flags spell aura area duration vaal
	statMap = {
		["chance_to_evade_attacks_%"] = {
			mod("EvadeChance", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
	},
#baseMod skill("radius", 40)
#mods

#skill Haste
#flags spell aura area
	statMap = {
		["cast_speed_+%_granted_from_skill"] = {
			mod("Speed", "INC", nil, ModFlag.Cast, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["attack_speed_+%_granted_from_skill"] = {
			mod("Speed", "INC", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_movement_velocity_+%"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["summon_totem_cast_speed_+%"] = {
			mod("TotemPlacementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" })
		},
		["base_projectile_speed_+%"] = {
			mod("ProjectileSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" })
		},
		["buff_time_passed_+%_only_buff_category"] = {
			mod("BuffExpireFaster", "MORE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" })
		},
	},
#baseMod skill("radius", 40)
#mods

#skill VaalHaste
#flags spell aura area duration vaal
	statMap = {
		["cast_speed_+%_granted_from_skill"] = {
			mod("Speed", "INC", nil, ModFlag.Cast, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["attack_speed_+%_granted_from_skill"] = {
			mod("Speed", "INC", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_movement_velocity_+%"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
	},
#baseMod skill("radius", 40)
#mods

#skill Hatred
#flags spell aura area
	statMap = {
		["physical_damage_%_to_add_as_cold"] = {
			mod("PhysicalDamageGainAsCold", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["hatred_aura_cold_damage_+%_final"] = {
			mod("ColdDamage", "MORE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["chill_and_freeze_duration_+%"] = {
			mod("EnemyChillDuration", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
			mod("EnemyFreezeDuration", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["movement_velocity_+%_on_chilled_ground"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }, {type = "Condition", var = "OnChilledGround"})
		}
	},
#baseMod skill("radius", 40)
#mods

#skill HeraldOfAgony
#flags cast minion
	minionList = {
		"HeraldOfAgonySpiderPlated",
	},
	statMap = {
		["skill_buff_grants_chance_to_poison_%"] = {
			mod("PoisonChance", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["herald_of_agony_poison_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, KeywordFlag.Poison, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["scorpion_minion_physical_damage_+%"] = {
			mod("MinionModifier", "LIST", { type = "HeraldOfAgonySpiderPlated", mod = mod("PhysicalDamage", "INC", nil, 0, 0, { type = "Multiplier", actor = "parent", var = "VirulenceStack", limitVar = "VirulenceStacksMax", limitActor = "parent"  })})
		},
		["scorpion_minion_attack_speed_+%"] = {
			mod("MinionModifier", "LIST", { type = "HeraldOfAgonySpiderPlated", mod = mod("Speed", "INC", nil, 0, 0, { type = "Multiplier", actor = "parent", var = "VirulenceStack", limitVar = "VirulenceStacksMax", limitActor = "parent" })})
		},
		["scorpion_minion_minimum_added_physical_damage"] = {
			mod("MinionModifier", "LIST", { type = "HeraldOfAgonySpiderPlated", mod = mod("PhysicalMin", "BASE", nil, 0, 0, { type = "Multiplier", actor = "parent", var = "VirulenceStack", limitVar = "VirulenceStacksMax", limitActor = "parent" })})
		},
		["scorpion_minion_maximum_added_physical_damage"] = {
			mod("MinionModifier", "LIST", { type = "HeraldOfAgonySpiderPlated", mod = mod("PhysicalMax", "BASE", nil, 0, 0, { type = "Multiplier", actor = "parent", var = "VirulenceStack", limitVar = "VirulenceStacksMax", limitActor = "parent" })})
		},
		["active_skill_minion_damage_+%_final"] = {
			mod("MinionModifier", "LIST", { mod = mod("Damage", "MORE", nil) }),
		},
		["withered_on_hit_for_2_seconds_%_chance"] = {
			flag("Condition:CanWither"),
		}
	},
#mods

#skill HeraldOfIce
#flags cast area
	statMap = {
		["herald_of_ice_cold_damage_+%"] = {
			mod("ColdDamage", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["spell_minimum_added_cold_damage"] = {
			mod("ColdMin", "BASE", nil, 0, KeywordFlag.Spell, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["spell_maximum_added_cold_damage"] = {
			mod("ColdMax", "BASE", nil, 0, KeywordFlag.Spell, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["attack_minimum_added_cold_damage"] = {
			mod("ColdMin", "BASE", nil, 0, KeywordFlag.Attack, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["attack_maximum_added_cold_damage"] = {
			mod("ColdMax", "BASE", nil, 0, KeywordFlag.Attack, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["skill_buff_grants_chance_to_freeze_%"] = {
			mod("FreezeChance", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		}
	},
#baseMod skill("radius", 12)
#mods

#skill IceShot
#flags attack projectile area duration
	parts = {
		{
			name = "Arrow",
			area = false,
		},
		{
			name = "Cone",
			area = true,
		},
	},
#baseMod mod("SkillPhysicalDamageConvertToCold", "BASE", 40, 0, 0, { type = "SkillPart", skillPart = 2 })
#baseMod skill("radius", 23)
#mods

#skill IceTrap
#flags spell trap area
#baseMod skill("radius", 18)
#baseMod skill("radiusLabel", "First Explosion:")
#baseMod skill("radiusSecondary", 9)
#baseMod skill("radiusSecondaryLabel", "Second Explosion:")
#baseMod skill("radiusTertiary", 6)
#baseMod skill("radiusTertiaryLabel", "Third Explosion:")
#mods

#skill DoubleSlash
#flags attack melee area
	parts = {
		{
			name = "One slash",
		},
		{
			name = "Both slashes",
		},
	},
#baseMod skill("radius", 38)
#baseMod skill("dpsMultiplier", 2, { type = "SkillPart", skillPart = 2 })
#mods

#skill LancingSteel
#flags attack projectile
	parts = {
		{
			name = "Single Projectile Hit",
		},
		{
			name = "All Projectiles Hit",
		},
	},
	preDamageFunc = function(activeSkill, output)
		if activeSkill.skillPart == 2 then
			activeSkill.skillData.dpsMultiplier = 1 + 0.4 * (output.ProjectileCount - 1)
		end
	end,
	statMap = {
		["number_of_projectiles_to_fire_+%_final_per_steel_ammo_consumed"] = {
			mod("ProjectileCount", "MORE", nil, 0, 0, { type = "Multiplier", var = "SteelShardConsumed", limit = 4 } )
		},
		["lancing_steel_damage_+%_at_close_range"] = {
			mod("Damage", "INC", nil, 0, bit.bor(KeywordFlag.Hit, KeywordFlag.Ailment), { type = "DistanceRamp", ramp = {{10,1},{70,0}} }),
		},
	},
#mods

#skill LightningArrow
#flags attack projectile
#baseMod skill("radius", 18)
#mods

#skill LightningStrike
#flags attack melee projectile
	parts = {
		{
			name = "Melee hit",
			melee = true,
			projectile = false,
		},
		{
			name = "Projectiles",
			melee = false,
			projectile = true,
		},
	},
	statMap = {
		["projectile_base_number_of_targets_to_pierce"] = {
			mod("PierceCount", "BASE", nil, 0, 0, { type = "SkillPart", skillPart = 2 }),
		},
	},
#mods

#skill VaalLightningStrike
#flags attack melee duration vaal
	parts = {
		{
			name = "Melee hit",
			melee = true,
			projectile = false,
		},
		{
			name = "Projectiles",
			melee = false,
			projectile = true,
		},
	},
	statMap = {
		["vaal_lightning_strike_beam_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, 0, { type = "SkillPart", skillPart = 2 }),
		},
	},
#mods

#skill MirrorArrow
#flags attack projectile minion duration
	minionList = {
		"Clone",
	},
#baseMod skill("minionUseBowAndQuiver", true)
#mods

#skill MambaStrike
#flags attack melee area duration
#baseMod skill("radius", 27)
#mods

#skill NewPhaseRun
#flags spell duration
	statMap = {
		["phase_run_melee_physical_damage_+%_final"] = {
			mod("PhysicalDamage", "MORE", nil, ModFlag.Melee, 0, { type = "SkillType", skillType = SkillType.Totem, neg = true }, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["base_movement_velocity_+%"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
	},
#mods

#skill CorrosiveShroud
#flags spell area
	statMap = {
		["plague_bearer_movement_speed_+%_while_infecting"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff", modCond = "PlagueBearerInfecting" }),
		},
		["corrosive_shroud_poison_dot_multiplier_+_while_aura_active"] = {
			mod("DotMultiplier", "BASE", nil, 0, KeywordFlag.Poison, { type = "GlobalEffect", effectType = "Buff", modCond = "PlagueBearerInfecting" }),
		},
		["corrosive_shroud_poison_damage_+%_final_while_accumulating_poison"] = {
			mod("Damage", "MORE", nil, 0, KeywordFlag.Poison, { type = "GlobalEffect", effectType = "Buff", modCond = "PlagueBearerIncubating" }),
		},
	},
#baseMod skill("radius", 25)
#mods

#skill PoachersMark
#flags spell curse duration mark
	statMap = {
		["life_granted_when_hit_by_attacks"] = {
			mod("SelfLifeOnHit", "BASE", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["mana_granted_when_hit_by_attacks"] = {
			mod("SelfManaOnHit", "BASE", nil, ModFlag.Attack, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["base_additional_physical_damage_reduction_%"] = {
			mod("PhysicalDamageReduction", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["minimum_added_physical_damage_taken"] = {
			mod("SelfPhysicalMin", "BASE", nil, ModFlag.Hit, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["maximum_added_physical_damage_taken"] = {
			mod("SelfPhysicalMax", "BASE", nil, ModFlag.Hit, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["base_damage_taken_+%"] = {
			mod("DamageTaken", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
	},
#baseMod skill("debuff", true)
#mods

#skill AccuracyAndCritsAura
#flags spell aura area
	statMap = {
		["accuracy_rating"] = {
			mod("Accuracy", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["skill_buff_grants_critical_strike_chance_+%"] = {
			mod("CritChance", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["auras_grant_damage_+%_to_you_and_your_allies"] = {
			mod("Damage", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" })
		},
		["precision_grants_area_of_effect_+%_final"] = {
			mod("AreaOfEffect", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" })
		},
	},
#baseMod skill("radius", 40)
#mods

#skill SnipersMark
#flags spell curse duration mark
	statMap = {
		["projectile_damage_taken_+%"] = {
			mod("ProjectileDamageTaken", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
	},
#baseMod skill("debuff", true)
#mods

#skill StormRain
#flags attack area projectile
	parts = {
		{
			name = "Arrow",
		},
		{
			name = "Beam",
		},
	},
	preDamageFunc = function(activeSkill, output)
		if activeSkill.skillPart == 2 then
			activeSkill.skillData.hitTimeOverride = activeSkill.skillData.hitFrequency / (1 + activeSkill.skillModList:Sum("INC", activeSkill.skillCfg, "StormRainBeamFrequency") / 100)
			activeSkill.skillData.dpsMultiplier = activeSkill.skillData.beamOverlapMultiplier or 1
		end
	end,
	statMap = {
		["prismatic_rain_beam_base_frequency_ms"] = {
			skill("hitFrequency", nil),
			div = 1000,
		},
		["prismatic_rain_beam_frequency_+%"] = {
			mod("StormRainBeamFrequency", "INC", nil),
		},
	},
#baseMod skill("radius", 10, { type = "SkillPart", skillPart = 1 })
#baseMod skill("radiusLabel", "Arrow Explosion:", { type = "SkillPart", skillPart = 1 })
#baseMod skill("radiusSecondary", 12, { type = "SkillPart", skillPart = 2 })
#baseMod skill("radiusSecondaryLabel", "Beam Width:", { type = "SkillPart", skillPart = 2 })
#mods

#skill Puncture
#flags attack melee projectile duration
	statMap = {
		["puncture_bleeding_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, KeywordFlag.Bleed),
		},
	},
#baseMod skill("bleedIsSkillEffect", true)
#mods

#skill ColdResistAura
#flags spell aura area
	statMap = {
		["base_cold_damage_resistance_%"] = {
			mod("ColdResist", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_maximum_cold_damage_resistance_%"] = {
			mod("ColdResistMax", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_avoid_freeze_%"] = {
			mod("AvoidFreeze", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_reduce_enemy_cold_resistance_%"] = {
			mod("ColdPenetration", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
	},
#baseMod skill("radius", 40)
#mods

#skill ColdImpurity
#flags spell aura area duration
	statMap = {
		["hits_ignore_my_cold_resistance"] = {
			flag("SelfIgnoreColdResistance", { type = "GlobalEffect", effectType = "AuraDebuff" }),
		},
		["base_maximum_cold_damage_resistance_%"] = {
			mod("ColdResistMax", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Aura" }),
		},
		["base_immune_to_freeze"] = {
			--Display only
		},
		["base_immune_to_chill"] = {
			--Display only
		},
	},
#baseMod mod("AvoidFreeze", "BASE", 100, 0, 0, { type = "GlobalEffect", effectType = "Aura", unscalable = true })
#baseMod mod("AvoidChill", "BASE", 100, 0, 0, { type = "GlobalEffect", effectType = "Aura", unscalable = true })
#mods

#skill RainOfArrows
#flags attack projectile area
#baseMod skill("radius", 10)
#baseMod flag("OneShotProj")
#mods

#skill VaalRainOfArrows
#flags attack projectile area duration vaal
#baseMod skill("radius", 10)
#baseMod flag("OneShotProj")
#mods

#skill Reave
#flags attack melee area
#baseMod skill("radius", 20)
	statMap = {
		["reave_area_of_effect_+%_final_per_stage"] = {
			mod("AreaOfEffect", "MORE", nil, 0, 0, { type = "Multiplier", var = "ReaveStage" }),
		},
		["reave_additional_max_stacks"] = {
			mod("Multiplier:ReaveMaxStages", "BASE", nil),
		}
	},
#baseMod mod("Multiplier:ReaveMaxStages", "BASE", 8)
#mods

#skill VaalReave
#flags attack melee area vaal
#baseMod skill("radius", 12)
	statMap = {
		["reave_area_of_effect_+%_final_per_stage"] = {
			mod("AreaOfEffect", "MORE", nil, 0, 0, { type = "Multiplier", var = "ReaveStage" }),
		},
		["reave_additional_max_stacks"] = {
			mod("Multiplier:ReaveMaxStages", "BASE", nil),
		},
	},
#baseMod mod("Multiplier:ReaveMaxStages", "BASE", 4)
#mods

#skill Riposte
#flags attack melee
#mods

#skill ScourgeArrow
#flags attack projectile
	initialFunc = function(activeSkill, output)
		activeSkill.skillData.dpsMultiplier = 1 / math.max(activeSkill.skillModList:Sum("BASE", cfg, "Multiplier:ScourgeArrowStage"), 1)
	end,
	parts = {
		{
			name = "Release",
			stages = true,
		},
		{ 
			name = "Thorn Arrows",
			stages = true,
		},
	},
	statMap = {
		["virulent_arrow_damage_+%_final_per_stage"] = {
			mod("Damage", "MORE", nil, 0, bit.bor(KeywordFlag.Hit, KeywordFlag.Ailment), { type = "Multiplier", var = "ScourgeArrowStage" }),
		},
		["virulent_arrow_pod_projectile_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, 0, { type= "SkillPart", skillPart = 2 }),
		},
		["virulent_arrow_maximum_number_of_stacks"] = {
			mod("Multiplier:ScourgeArrowMaxStages", "BASE", nil),
		},
	},
#mods

#skill ShatteringSteel
#flags attack projectile area
	parts = {
		{
			name = "Projectile",
			area = false,
		},
		{
			name = "Cone AoE",
		},
	},
	statMap = {
		["shattering_steel_hit_damage_+%_final_scaled_by_projectile_distance_per_ammo_consumed"] = {
			mod("Damage", "MORE", nil, ModFlag.Hit, 0, { type = "Multiplier", var = "SteelShardConsumed", limit = 2 }, { type = "DistanceRamp", ramp = {{10,1},{70,0} } } ),
		},
		["additional_block_chance_against_projectiles_%_per_steel_charge"] = {
			mod("ProjectileBlockChance", "BASE", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff", unscalable = true }, { type = "Multiplier", var = "SteelWardCount", limit = 6 } ),
		},
		["no_additional_projectiles_if_no_steel_ammo"] = {
			flag("NoAdditionalProjectiles", { type = "MultiplierThreshold", var = "SteelShardConsumed", threshold = 0, upper = true }),
		},
	},
#baseMod skill("radius", 28)
#mods

#skill PhysCascadeTrap
#flags spell area trap duration
	parts = {
		{
			name = "One wave hitting",
		},
		{
			name = "Average waves hitting configured size enemy",
		},
		{
			name = "All waves hitting",
		},
		{
			name = "Average active traps, one wave",
		},
		{
			name = "Average active traps, average waves",
		},
		{
			name = "Average active traps, all waves",
		},
	},
	preDamageFunc = function(activeSkill, output, breakdown)
		local skillCfg = activeSkill.skillCfg
		local skillData = activeSkill.skillData
		local skillPart = activeSkill.skillPart
		local skillModList = activeSkill.skillModList
		local t_insert = table.insert
		local s_format = string.format

		local baseInterval = skillData.repeatInterval
		local incFrequency = (1 + skillModList:Sum("INC", skillCfg, "TrapThrowingSpeed", "SeismicPulseFrequency") / 100)
		local moreFrequency = skillModList:More(skillCfg, "TrapThrowingSpeed", "SeismicPulseFrequency")
		local wavePulseRate = incFrequency * moreFrequency / baseInterval
		skillData.hitTimeOverride = 1 / wavePulseRate
		output.WavePulseRate = wavePulseRate
		local incDuration = (1 + skillModList:Sum("INC", skillCfg, "Duration") / 100)
		local moreDuration = skillModList:More(skillCfg, "Duration")
		local duration = skillData.duration * incDuration * moreDuration
		local pulses = math.floor(duration * wavePulseRate)
		output.PulsesPerTrap = pulses
		local effectiveDuration = pulses / wavePulseRate
		local cooldown = output.TrapCooldown
		local averageActiveTraps = effectiveDuration / cooldown
		output.AverageActiveTraps = averageActiveTraps
		local function hitChance(enemyRadius, areaDamageRadius, areaSpreadRadius) -- not to be confused with attack hit chance
			local damagingAreaRadius = areaDamageRadius + enemyRadius - 1	-- radius where area damage can land to hit the enemy;
			-- -1 because of two assumptions: PoE coordinates are integers and damage is not registered if the two areas only share a point or vertex. If either is not correct, then -1 is not needed.
			return math.min(damagingAreaRadius * damagingAreaRadius / (areaSpreadRadius * areaSpreadRadius), 1)
		end
		local enemyRadius = skillModList:Override(skillCfg, "EnemyRadius") or skillModList:Sum("BASE", skillCfg, "EnemyRadius")
		local waveRadius = output.AreaOfEffectRadiusSecondary
		local fullRadius = output.AreaOfEffectRadius
		local overlapChance = hitChance(enemyRadius, waveRadius, fullRadius)
		output.OverlapChance = overlapChance * 100
		if breakdown then
			breakdown.OverlapChance = { }
			t_insert(breakdown.OverlapChance, "Chance for individual wave to land within range to damage enemy:")
			t_insert(breakdown.OverlapChance, "^8= (area where wave can spawn to damage enemy) / (total area)")
			t_insert(breakdown.OverlapChance, "^8= (^7secondary radius^8 + ^7enemy radius^8 - 1) ^ 2 / ^7radius^8 ^ 2")
			t_insert(breakdown.OverlapChance, s_format("^8= (^7%d^8 +^7 %d^8 - 1) ^ 2 /^7 %d^8 ^ 2", waveRadius, enemyRadius, fullRadius))
			t_insert(breakdown.OverlapChance, s_format("^8=^7 %.3f^8%%", overlapChance * 100))
			breakdown.WavePulseRate = { }
			t_insert(breakdown.WavePulseRate, "Pulse rate:")
			t_insert(breakdown.WavePulseRate, s_format("%.2f ^8(base pulse rate)", 1 / baseInterval))
			t_insert(breakdown.WavePulseRate, s_format("* %.2f ^8(increased/reduced pulse frequency)", incFrequency))
			t_insert(breakdown.WavePulseRate, s_format("* %.2f ^8(more/less pulse frequency)", moreFrequency))
			t_insert(breakdown.WavePulseRate, s_format("= %.2f^8/s", wavePulseRate))
			breakdown.PulsesPerTrap = { }
			t_insert(breakdown.PulsesPerTrap, "Pulses per trap:")
			t_insert(breakdown.PulsesPerTrap, s_format("%.3f ^8(unrounded skill duration)", duration))
			t_insert(breakdown.PulsesPerTrap, s_format("* %.2f ^8(pulse rate)", wavePulseRate))
			t_insert(breakdown.PulsesPerTrap, s_format("= %.2f ^8pulses", duration * wavePulseRate))
			t_insert(breakdown.PulsesPerTrap, "^8rounded down")
			t_insert(breakdown.PulsesPerTrap, s_format("= %d ^8pulses", pulses))
			t_insert(breakdown.PulsesPerTrap, s_format("^8Next breakpoint: %d%% increased Trap Throwing Speed / %d%% increased Duration",
					math.ceil(100 * ((pulses + 1) * baseInterval / (duration * moreFrequency) - incFrequency)),
					math.ceil(100 * ((pulses + 1) / (wavePulseRate * skillData.duration * moreDuration) - incDuration))
			))
			t_insert(breakdown.PulsesPerTrap, s_format("^8Previous breakpoint: %d%% reduced Trap Throwing Speed / %d%% reduced Duration",
					-math.ceil(100 * (pulses * baseInterval / (duration * moreFrequency) - incFrequency) - 1),
					-math.ceil(100 * (pulses / (wavePulseRate * skillData.duration * moreDuration) - incDuration) - 1)
			))
			breakdown.AverageActiveTraps = { }
			t_insert(breakdown.AverageActiveTraps, "Average active traps, not considering stored cooldown uses:")
			t_insert(breakdown.AverageActiveTraps, s_format("%.2f^8 /^7 %.2f^8 (pulses / pulse rate = effective skill duration)", pulses, wavePulseRate))
			t_insert(breakdown.AverageActiveTraps, s_format("/ %.2f ^8(cooldown)", cooldown))
			t_insert(breakdown.AverageActiveTraps, s_format("= %.2f traps", averageActiveTraps))
		end
		local maxWaves = skillModList:Sum("BASE", skillCfg, "MaximumWaves")
		local dpsMultiplier = 1
		if skillPart == 2 then
			dpsMultiplier = maxWaves * overlapChance
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, "^8= ^7maximum waves^8 * ^7overlap chance^8")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %d^8 *^7 %.2f^8", maxWaves, overlapChance))
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.3f", dpsMultiplier))
			end
		elseif skillPart == 3 then
			dpsMultiplier = maxWaves
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %d (maximum waves)", dpsMultiplier))
			end
		elseif skillPart == 4 then
			dpsMultiplier = averageActiveTraps
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.2f (average active traps)", dpsMultiplier))
			end
		elseif skillPart == 5 then
			dpsMultiplier = averageActiveTraps * maxWaves * overlapChance
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, "^8= ^7average active traps^8 * ^7maximum waves^8 * ^7overlap chance^8")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.2f^8 *^7 %d^8 *^7 %.2f", averageActiveTraps, maxWaves, overlapChance))
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.3f", dpsMultiplier))
			end
		elseif skillPart == 6 then
			dpsMultiplier = averageActiveTraps * maxWaves
			if breakdown then
				breakdown.SkillDPSMultiplier = {}
				t_insert(breakdown.SkillDPSMultiplier, "DPS multiplier")
				t_insert(breakdown.SkillDPSMultiplier, "^8= ^7average active traps^8 * ^7maximum waves")
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.2f^8 *^7 %d", averageActiveTraps, maxWaves))
				t_insert(breakdown.SkillDPSMultiplier, s_format("^8=^7 %.3f", dpsMultiplier))
			end
		end
		if dpsMultiplier ~= 1 then
			skillData.dpsMultiplier = (skillData.dpsMultiplier or 1) * dpsMultiplier
			output.SkillDPSMultiplier = (output.SkillDPSMultiplier or 1) * dpsMultiplier
		end
	end,
	statMap = {
		["base_skill_show_average_damage_instead_of_dps"] = {},
		["phys_cascade_trap_base_interval_duration_ms"] = {
			skill("repeatInterval", nil),
			div = 1000,
		},
		["phys_cascade_trap_number_of_cascades"] = {
			mod("MaximumWaves", "BASE", nil),
		},
		["seismic_trap_frequency_+%"] = {
			mod("SeismicPulseFrequency", "INC", nil),
		},
	},
#baseMod skill("radius", 18)
#baseMod skill("radiusLabel", "Large Burst:")
#baseMod skill("radiusSecondary", 9)
#baseMod skill("radiusSecondaryLabel", "Small Burst:")
#mods

#skill ShrapnelBallista
#flags attack projectile totem ballista
#mods

#skill SiegeBallista
#flags attack projectile totem ballista
#baseMod flag("ProjectileRain")
#mods

#skill SmokeMine
#flags spell mine area buff
	statMap = {
		["base_movement_velocity_+%"] = {
			mod("MovementSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["skill_buff_grants_attack_and_cast_speed_+%"] = {
			mod("Speed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
	},
#baseMod skill("radius", 18)
#mods

#skill ThrownShield
#flags attack projectile shieldAttack
	parts = {
		{
			name = "Shield",
		},
		{
			name = "Shards",
		},
	},
	statMap = {
		["thrown_shield_secondary_projectile_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, 0, { type = "SkillPart", skillPart = 2 }),
		},
		["primary_projectile_chains_+"] = {
			mod("ChainCountMax", "BASE", nil, 0, 0, { type = "SkillPart", skillPart = 1 }),
		},
	},
#mods

#skill ThrownWeapon
#flags attack projectile
#baseMod mod("PierceChance", "BASE", 100)
#mods

#skill VaalThrownWeapon
#flags attack projectile vaal
	statMap = {
		["base_number_of_projectiles_in_spiral_nova"] = {
			mod("ProjectileCount", "BASE", nil),
		},
	},
#mods

#skill RainOfSpores
#flags attack projectile area duration
	preDamageFunc = function(activeSkill, output)
		activeSkill.skillData.dpsMultiplier = math.min(activeSkill.skillData.podOverlapMultiplier or 1, output.ProjectileCount)
	end,
#baseMod skill("dotIsArea", true)
#baseMod flag("DotCanStack")
#baseMod flag("OneShotProj")
#baseMod skill("radius", 18)
#baseMod skill("radiusLabel", "Pod Area:")
#mods

#skill SpectralHelix
#flags attack projectile bounce
	statMap = {
		["spectral_spiral_weapon_base_number_of_bounces"] = {
			mod("BounceCount", "BASE", nil),
		},
	},
#baseMod flag("NoAdditionalProjectiles")
#baseMod flag("AdditionalProjectilesAddBouncesInstead")
#mods

#skill SplitArrow
#flags attack projectile
#mods

#skill ImpactingSteel
#flags attack projectile area
	parts = {
		{
			name = "Main Projectile",
		},
		{
			name = "Split Projectile",
		},
	},
	statMap = {
		["impacting_steel_secondary_projectile_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, 0, { type = "SkillPart", skillPart = 2 } )
		},
		["splitting_steel_area_+%_final_after_splitting"] = {
			mod("AreaOfEffect", "MORE", nil, 0, 0, { type = "SkillPart", skillPart = 2 } )
		},
	},
#baseMod flag("NoAdditionalProjectiles")
#mods

#skill SummonIceGolem
#flags spell minion golem
	minionList = {
		"SummonedIceGolem",
	},
	statMap = {
		["ice_golem_grants_critical_strike_chance_+%"] = {
			mod("CritChance", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
		["ice_golem_grants_accuracy_+%"] = {
			mod("Accuracy", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" }),
		},
	},
#baseMod skill("allowTotemBuff", true)
#baseMod flag("Condition:HaveColdGolem", { type = "GlobalEffect", effectType = "Buff" })
#mods

#skill TemporalChains
#flags spell curse area duration hex
	statMap = {
		["temporal_chains_action_speed_+%_final"] = {
			mod("TemporalChainsActionSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }, { type = "Condition", var = "RareOrUnique", neg = true }),
		},
		["buff_time_passed_+%_other_than_temporal_chains"] = {
			mod("BuffExpireFaster", "MORE", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }),
		},
		["curse_effect_+%_final_vs_players"] = {
			mod("CurseEffectAgainstPlayer", "MORE", nil),
		},
		["temporal_chains_action_speed_+%_vs_rare_or_unique_final"] = {
			mod("TemporalChainsActionSpeed", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Curse" }, { type = "Condition", var = "RareOrUnique" }),
		},
	},
#baseMod skill("debuff", true)
#baseMod skill("radius", 22)
#mods

#skill TornadoShot
#flags attack projectile
#mods

#skill BoneLance
#flags spell projectile corpse
	statMap = {
		["unearth_base_corpse_level"] = {
			mod("CorpseLevel", "BASE", nil),
		},
	},
#baseMod skill("corpseMonsterVariety", "Bone Archer")
#mods

#skill SnappingAdder
#flags attack projectile
	parts = {
		{
			name = "Outgoing Projectile",
		},
		{
			name = "Returning Projectile",
		},
	},
#baseMod flag("Condition:ReturningProjectile", { type = "SkillPart", skillPart = 2 })
#mods

#skill VaalSnappingAdder
#flags attack projectile duration
#mods

#skill ViperStrike
#flags attack melee duration
	statMap = {
		["viper_strike_dual_wield_damage_+%_final"] = {
			mod("Damage", "MORE", nil, 0, 0, { type = "Condition", var = "DualWielding" }),
		},
		["viper_strike_dual_wield_attack_speed_+%_final"] = {
			mod("Speed", "MORE", nil, ModFlag.Attack, 0, { type = "Condition", var = "DualWielding" }),
		},
	},
#baseMod skill("poisonIsSkillEffect", true)
#mods

#skill VolatileDead
#flags spell area
	statMap = {
		["spell_minimum_base_fire_damage"] = {
			skill("FireMin", nil, { type = "SkillPart", skillPart = 1 }),
		},
		["spell_maximum_base_fire_damage"] = {
			skill("FireMax", nil, { type = "SkillPart", skillPart = 1 }),
		},
	},
#baseMod skill("explodeCorpse", true, { type = "SkillPart", skillPart = 2 })
	parts = {
		{
			name = "Spell",
			spell = true,
			cast = false,
		},
		{
			name = "Corpse Explosion",
			spell = false,
			cast =  true,
		},
	},
#baseMod skill("radius", 15)
#mods

#skill WhirlingBlades
#flags attack melee
	statMap = {
		["whirling_blades_evasion_rating_+%_while_moving"] = {
			mod("Evasion", "INC", nil, 0, 0, { type = "Condition", var = "Moving" } )
		},
	},
#mods

#skill WildStrike
#flags attack melee projectile chaining area
	parts = {
		{
			name = "Fire hit",
			melee = true,
			projectile = false,
			chaining = false,
			area = false,
		},
		{
			name = "Fire explosion",
			melee = false,
			projectile = false,
			chaining = false,
			area = true,
		},
		{
			name = "Lightning hit",
			melee = true,
			projectile = false,
			chaining = false,
			area = false,
		},
		{
			name = "Lightning bolt",
			melee = false,
			projectile = false,
			chaining = true,
			area = false,
		},
		{
			name = "Cold hit",
			melee = true,
			projectile = false,
			chaining = false,
			area = false,
		},
		{
			name = "Icy wave",
			melee = false,
			projectile = true,
			chaining = false,
			area = false,
		},
	},
	statMap = {
		["elemental_strike_physical_damage_%_to_convert"] = {
		},
	},
#baseMod mod("PhysicalDamageConvertToFire", "BASE", 100, 0, 0, { type = "SkillPart", skillPartList =  { 1, 2 } })
#baseMod mod("PhysicalDamageConvertToLightning", "BASE", 100, 0, 0, { type = "SkillPart", skillPartList =  { 3, 4 } })
#baseMod mod("PhysicalDamageConvertToCold", "BASE", 100, 0, 0, { type = "SkillPart", skillPartList =  { 5, 6 } })
#baseMod skill("radius", 24, { type = "SkillPart", skillPart = 2 })
#mods

#skill Slither
#flags spell duration
	statMap = {
		["slither_wither_stacks"] = {
			flag("Condition:CanWither"),
		},
	},
#baseMod flag("Condition:CanBeElusive", { type = "GlobalEffect", effectType = "Buff" })
#baseMod skill("radius", 26)
#mods

#skill PoisonousConcoction
#flags attack area projectile
#baseMod skill("radius", 18)
	parts = {
		{
			name = "No Flask",
		},
		{
			name = "Life",
		},
	},
	preDamageFunc = function(activeSkill, output)
		local multiplier = activeSkill.skillModList:Sum("BASE", activeSkill.skillCfg, "ChaosPerLifeFlaskPercent") or 0
		local addedFromFlask = (output.LifeFlaskRecovery or 0) * (multiplier / 100)
		activeSkill.skillModList:NewMod("ChaosMin", "BASE", addedFromFlask, "Life Flask charges consumed")
		activeSkill.skillModList:NewMod("ChaosMax", "BASE", addedFromFlask, "Life Flask charges consumed")
	end,
	statMap = {
		["flask_throw_added_chaos_damage_%_of_flask_life_to_recover"] = {
			mod("ChaosPerLifeFlaskPercent", "BASE", nil, 0, 0, { type = "SkillPart", skillPart = 2 }),
		},
	},
#mods

#skill TemporalRift
#flags spell
	statMap = {
		["chronomancer_buff_cooldown_speed_+%"] = {
			mod("CooldownRecovery", "INC", nil, 0, 0, { type = "GlobalEffect", effectType = "Buff" })
		},
	},
#mods

#skill Tornado
#flags spell duration physical area
	preDamageFunc = function(activeSkill, output)
		activeSkill.skillData.hitTimeOverride = activeSkill.skillData.damageInterval
	end,
	statMap = {
		["tornado_base_damage_interval_ms"] = {
			skill("damageInterval", nil ),
			div = 1000, 
		},
	},
#mods

#skill IntuitiveLink
#flags spell duration
#mods

#skill VampiricLink
#flags spell duration
#mods